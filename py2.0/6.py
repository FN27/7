# l = 0
# for i in x:
#     if i % 2 == 0:
#         o = o + i
#     else:
#         l = i + l
# print(o, l)
#
# for i in x:
#     if not i in o:
#         o.append(i)
# print(o)
# def to_dict(list):
#     dict = {}
#     for i in list:
#         dict[i] = i
#     return dict
# print(to_dict(o))
import collections

o = "11364"


def str_in_dict(str):
    dict = []
    for i in str:
        dict.append(i)
    return dict


def count_it(list_1):
    c = collections.Counter()
    for i in list_1:
        c[i] += 1
    return c


print(count_it(str_in_dict(o)))

# TODO 1:Начальник отдела кадров хочет узнать, сколько мужчин-однофамильцев работает в организации. Имеется список фамилий, и на основании этого списка нужно вычислить количество фамилий, которые совпадают с другими.
#   Формат ввода: В первой строке указывается количество мужчин — сотрудников организации (N). Затем идут N строк с фамилиями этих сотрудников в произвольном порядке.
#   Формат вывода: Количество однофамильцев в организации.
# TODO 2:Возьмём число. Умножим его на его же первую цифру. Результат умножим на первую цифру результата. И так далее. Например, начнём с 3:
#   3 → 3 * 3 = 9
#   9 → 9 * 9 = 81
#   81 → 81 * 8 = 648
#   648 → 648 * 6 = 3888
#   3888 → 3888 * 3 = 11664
#   11664 → 11884 * 1 = 11664
#   Очевидно, когда первая цифра очередного числа в такой последовательности становится равной 1, числа перестают изменяться. Но это происходит не при всех начальных числах.
#   Напишите программу, которая будет хотя бы приблизительно определять судьбу введённого числа.
#   Формат ввода: Вводится натуральное число n, меньшее миллиарда.
#   Формат вывода: Начиная с числа n, умножайте имеющееся число на его первую цифру, пока у получившегося числа первая цифра не станет равной 1, либо пока оно не превысит миллиарда. Выведите результат.
#   Пример 1. Ввод: 3. Вывод: 11664.
#   Пример 2. Ввод: 5. Вывод:
